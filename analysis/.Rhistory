getwd()
dice = rbinom(n = 1000000, size = 1, prob = .5)
right = rbinom(n = 1000000, size = 1, prob = .8)
sum(dice==right)
dice = rbinom(n = 1000000, size = 1, prob = 1)
right = rbinom(n = 1000000, size = 1, prob = .8)
sum(dice==right)
dice
ttt <- c(1, 2)
ttt
2*ttt
library(readxl)
install.packages("readxl")
library(readxl)
library(nlme)
library(magrittr)
library(tidyverse)
help(install_github)
help(devtools::install_github)
install.packages("sumSome")
knitr::opts_chunk$set(echo = TRUE)
G <- simData(prop = 0.6, m = 5, B = 10, alpha = 0.4, p = TRUE, seed = 42)
library(sumSome)
G <- simData(prop = 0.6, m = 5, B = 10, alpha = 0.4, p = TRUE, seed = 42)
S <- c(1,2) # subset of interest
G
res <- sumStats(G = G, S = S, alternative = "lower", alpha = 0.4, truncFrom = 0.4, truncTo = 0.5)
res
summary(res)
discoveries(res) # lower confidence bound for the number of true discoveries
tdp(res) # lower confidence bound for the TDP
fdp(res) # upper confidence bound for the FDP
G <- simData(prop = 0.6, m = 5, B = 10, alpha = 0.05, p = TRUE, seed = 42)
S <- c(1,2) # subset of interest
res <- sumStats(G = G, S = S, alternative = "lower", alpha = 0.4, truncFrom = 0.4, truncTo = 0.5)
summary(res)
discoveries(res) # lower confidence bound for the number of true discoveries
tdp(res) # lower confidence bound for the TDP
fdp(res) # upper confidence bound for the FDP
G <- simData(prop = 0.05, m = 5, B = 10, alpha = 0.4, p = TRUE, seed = 42)
S <- c(1,2) # subset of interest
res <- sumStats(G = G, S = S, alternative = "lower", alpha = 0.4, truncFrom = 0.4, truncTo = 0.5)
summary(res)
discoveries(res) # lower confidence bound for the number of true discoveries
tdp(res) # lower confidence bound for the TDP
fdp(res) # upper confidence bound for the FDP
help(simData)
G
G <- simData(prop = 0.6, m = 5, B = 10, alpha = 0.4, p = TRUE, seed = 42)
G
G <- simData(prop = 0.6, m = 5, B = 10, alpha = 0.4, p = FALSE, seed = 42)
G
G <- simData(prop = 0.6, m = 5, B = 10, alpha = 0.4, p = FALSE, seed = 42)
S <- c(1,2) # subset of interest
res <- sumStats(G = G, S = S, alternative = "lower", alpha = 0.4, truncFrom = 0.4, truncTo = 0.5)
summary(res)
S
discoveries(res) # lower confidence bound for the number of true discoveries
tdp(res) # lower confidence bound for the TDP
fdp(res) # upper confidence bound for the FDP
G <- simData(prop = 0.6, m = 5, B = 10, alpha = 0.4, p = FALSE, seed = 42)
S <- c(1,2) # subset of interest
res <- sumStats(G = G, S = S, alternative = "lower", alpha = 0.4, truncFrom = 0.4, truncTo = 0.5)
summary(res)
discoveries(res) # lower confidence bound for the number of true discoveries
G <- simData(prop = 0.6, m = 5, B = 10, alpha = 0.4, p = TRUE, seed = 42)
S <- c(1,2) # subset of interest
res <- sumStats(G = G, S = S, alternative = "lower", alpha = 0.4, truncFrom = 0.4, truncTo = 0.5)
summary(res)
discoveries(res) # lower confidence bound for the number of true discoveries
tdp(res) # lower confidence bound for the TDP
fdp(res) # upper confidence bound for the FDP
help(anova)
citation("emmeans")
citation("lmer")
citation("lme4")
citation("car")
citation("stats")
ceil(2.3)
ceiling(2.3)
help(ln)
??ln
??log
log(10)
ln(10)
ln(2.71)
log(2.71)
log(2.716)
z_onetailed <- 1.64
z_pow80 <- 0.84
N_estim <- ceiling(4*(z_onetailed+z_pow80)^2/log((1+corr_SDA_CVF)/(1-corr_SDA_CVF)) + 3);
# lag1 autocorrelation of asynchronies
# (Semjen, Schulze & Vorberg 2000, figure 4G; Repp 2011, figure 8)
autocorr_lag1 <- 0.4
# data from Sasaki et al 2011
# SD of intertap interval
aux1_df = read.csv("Sasaki 2011 figure 3C.dat", sep='\t', header=TRUE) # ISI=250ms
aux2_df = read.csv("Sasaki 2011 figure 3D.dat", sep='\t', header=TRUE) # ISI=500ms
data_iti_Sasaki_df <- rbind(aux1_df, aux2_df)
# mean force
aux1_df = read.csv("Sasaki 2011 figure 5A.dat", sep='\t', header=TRUE) # ISI=250ms
aux2_df = read.csv("Sasaki 2011 figure 5B.dat", sep='\t', header=TRUE) # ISI=500ms
# merge mean force data
data_force_mean_Sasaki_df <- rbind(aux1_df, aux2_df)
# SD force
aux1_df = read.csv("Sasaki 2011 figure 5E.dat", sep='\t', header=TRUE) # ISI=250ms
aux2_df = read.csv("Sasaki 2011 figure 5F.dat", sep='\t', header=TRUE) # ISI=500ms
# merge SD force data
data_force_sd_Sasaki_df <- rbind(aux1_df, aux2_df)
# merge mean and sd force data
data_force_Sasaki_df <- full_join(data_force_mean_Sasaki_df, data_force_sd_Sasaki_df,
by=join_by(age,cond,isi))
library(tidyverse)
# lag1 autocorrelation of asynchronies
# (Semjen, Schulze & Vorberg 2000, figure 4G; Repp 2011, figure 8)
autocorr_lag1 <- 0.4
# data from Sasaki et al 2011
# SD of intertap interval
aux1_df = read.csv("Sasaki 2011 figure 3C.dat", sep='\t', header=TRUE) # ISI=250ms
aux2_df = read.csv("Sasaki 2011 figure 3D.dat", sep='\t', header=TRUE) # ISI=500ms
data_iti_Sasaki_df <- rbind(aux1_df, aux2_df)
# mean force
aux1_df = read.csv("Sasaki 2011 figure 5A.dat", sep='\t', header=TRUE) # ISI=250ms
aux2_df = read.csv("Sasaki 2011 figure 5B.dat", sep='\t', header=TRUE) # ISI=500ms
# merge mean force data
data_force_mean_Sasaki_df <- rbind(aux1_df, aux2_df)
# SD force
aux1_df = read.csv("Sasaki 2011 figure 5E.dat", sep='\t', header=TRUE) # ISI=250ms
aux2_df = read.csv("Sasaki 2011 figure 5F.dat", sep='\t', header=TRUE) # ISI=500ms
# merge SD force data
data_force_sd_Sasaki_df <- rbind(aux1_df, aux2_df)
# merge mean and sd force data
data_force_Sasaki_df <- full_join(data_force_mean_Sasaki_df, data_force_sd_Sasaki_df,
by=join_by(age,cond,isi))
data_force_Sasaki_df <- data_force_Sasaki_df %>%
mutate(force_cv = force_sd/force_mean) %>%
select(age,isi,cond,force_mean,force_sd,force_cv)
# merge Sasaki2010 ITI and force data
data_Sasaki_df <- full_join(data_force_Sasaki_df, data_iti_Sasaki_df, by=join_by(age,cond,isi)) %>%
# transform to SD of asynchronies
mutate(asyn_sd = iti_sd/sqrt(2*(1-autocorr_lag1)))
# data from Inui et al 2002
data_force_Inui_df = read.csv("Inui 2002 figure 5A.dat", sep='\t', header=TRUE) # cv of force
aux1_df = read.csv("Inui 2002 figure 2B.dat", sep='\t', header=TRUE) # mean intertap interval
aux2_df = read.csv("Inui 2002 figure 5B.dat", sep='\t', header=TRUE) # cv of intertap interval
# merge Inui2002 ITI data
data_iti_Inui_df <- full_join(aux1_df, aux2_df, by=join_by(tap,isi)) %>%
mutate(iti_sd = iti_mean*iti_cv,
# transform to SD of asynchronies
asyn_sd = iti_sd/sqrt(2*(1-autocorr_lag1)))
# merge Inui2002 ITI and force data
data_Inui_df <- full_join(data_iti_Inui_df, data_force_Inui_df, by=join_by(tap,isi)) %>%
# remove tap=4 due to different experimental condition
filter(tap!=4)
# merge all data
data_df <- full_join(data_Sasaki_df, data_Inui_df, by=join_by(isi,force_cv,iti_sd,asyn_sd))
# compute correlation between asyn_sd and Force_cv
corr_SDA_CVF <- cor(data_df$force_cv, data_df$asyn_sd, method='pearson')
# estimate number of participants
z_onetailed <- 1.64
z_pow80 <- 0.84
N_estim <- ceiling(4*(z_onetailed+z_pow80)^2/log((1+corr_SDA_CVF)/(1-corr_SDA_CVF)) + 3);
print(paste('Correlation coefficient SD_A vs CV_F from literature =',corr_SDA_CVF))
print(paste('Estimated number of participants:',N_estim))
getwd()
setwd('labo/proyectos/context/Context2024/analysis/')
library(tidyverse)
library(lme4)
library(lmerTest)
library(car)
library(magrittr)
library(emmeans)
data_df = read.csv("../data/data_GroupSubjCond_OS_df.csv")
dict_df = read.csv("../data/data_GroupSubjCond_OS_dict.csv")
DeltaT <- 50
# select relevant data
data2_df <- data_df %>%
select('Exp_name','General_condition','Subject',
'Relative_beep','mean_asyn') %>%
rename(beep=Relative_beep, asyn=mean_asyn) %>%
mutate(subject = if_else(Exp_name=='Experiment_PS', Subject+100, # make subject unique
if_else(Exp_name=='Experiment_SC', Subject+200, Subject+300)),
context = if_else(Exp_name=='Experiment_PS_SC', 'comb', 'pure')) # define context
# add missing data
data3_df <- inner_join(
data2_df,
dict_df[,c('General_condition','Name','Perturb_type','Perturb_size')],
by='General_condition') %>%
filter(Perturb_size==50 | Perturb_size==-50) %>%
mutate(perturb_type = if_else(Perturb_type==0, 'SC', 'PS'),
perturb_sign = if_else(Perturb_size==50, 'pos', 'neg'),
pred_asyn = case_when(
# SC and PS cases
beep==0 & perturb_sign=='pos' ~ asyn+DeltaT,
beep==0 & perturb_sign=='neg' ~ asyn-DeltaT,
# PS cases
beep==1 & perturb_type=='PS'& perturb_sign=='pos' ~ asyn-DeltaT,
beep==1 & perturb_type=='PS'& perturb_sign=='neg' ~ asyn+DeltaT,
TRUE ~ asyn)
) %>%
# drop unused columns
select(-c('Exp_name','General_condition','Perturb_type','Perturb_size','Name','Subject')) %>%
# reorder columns
select(c('context','perturb_type','perturb_sign','subject','beep','asyn','pred_asyn'))
# define limits of resynchronization phase (beeps)
resynch_start <- 1
resynch_end <- 6
# select resynchronization phase only
data3_red_df <- data3_df %>% filter(
beep>=resynch_start & beep<=resynch_end
)
# specific model: 3rd-order interaction
# main effect of context or any of its interactions
model_diff_3int <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_type
+ context:perturb_sign
+ context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_diff_3int <- Anova(model_diff_3int, type="III")
print(anova_table_diff_3int)
# alternative model: up to 2nd-order interactions
model_diff_alt <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_type
+ context:perturb_sign
+ perturb_type:perturb_sign
+ (1|subject),
data = data3_red_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_diff_alt <- Anova(model_diff_alt, type="III")
print(anova_table_diff_alt)
anova_table_comp <- anova(model_diff_alt,model_diff_3int, test=TRUE)
print(anova_table_comp)
# post-hoc comparisons
model_diff_3int_emm <- emmeans(model_diff_3int, ~ context:perturb_type:perturb_sign)
# contrasts (post-hoc comparisons)
# print estimates and confidence intervals
model_diff_3int_emm_pairs <- pairs(model_diff_3int_emm, simple="context", infer=c(TRUE,TRUE))
print(model_diff_3int_emm_pairs)
# print corrected p-values
model_diff_3int_emm_test <- test(model_diff_3int_emm_pairs, cross.adjust="fdr", type="response")
print(model_diff_3int_emm_test)
# compute confidence intervals
model_diff_3int_emm_test_CI <- model_diff_3int_emm_test %>%
mutate(LCI = estimate - 1.96*SE,
UCI = estimate + 1.96*SE)
print(model_diff_3int_emm_test_CI)
data3_red_inv_df <- data3_red_df %>%
# switch sign of negative perturbations
mutate(asyn = if_else(perturb_sign=='pos',-asyn,asyn))
# specific model: main effect of perturb_sign or any of its interactions
# (asymmetry = difference between signs)
# interaction between perturb_sign, perturb_type and context (perturb_sign has a
# differential effect depending on the type of perturbation AND the context, i.e. pure
# context makes SCs more asymmetrical but PSs less asymmetrical)
model_asym_3int <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_sign
+ perturb_type:perturb_sign
+ context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_3int <- Anova(model_asym_3int, type="III")
print(anova_table_asym_3int)
# alternative model: all first-order interactions
model_asym_alt <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_type
+ context:perturb_sign
+ perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_alt <- Anova(model_asym_alt, type="III")
print(anova_table_asym_alt)
# model comparison
anova(model_asym_alt, model_asym_3int, test=TRUE)
data3_red_inv_df <- data3_red_df %>%
# switch sign of negative perturbations
mutate(asyn = if_else(perturb_sign=='pos',-asyn,asyn))
# specific model: main effect of perturb_sign or any of its interactions
# (asymmetry = difference between signs)
# interaction between perturb_sign, perturb_type and context (perturb_sign has a
# differential effect depending on the type of perturbation AND the context, i.e. pure
# context makes SCs more asymmetrical but PSs less asymmetrical)
model_asym_3int <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_sign
+ perturb_type:perturb_sign
+ context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_3int <- Anova(model_asym_3int, type="III")
print(anova_table_asym_3int)
# alternative model: all first-order interactions
model_asym_alt <- lmer(asyn ~ context + perturb_type + perturb_sign
# + context:perturb_type
+ context:perturb_sign
+ perturb_type:perturb_sign
+ context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_alt <- Anova(model_asym_alt, type="III")
print(anova_table_asym_alt)
# model comparison
anova(model_asym_alt, model_asym_3int, test=TRUE)
data3_red_inv_df <- data3_red_df %>%
# switch sign of negative perturbations
mutate(asyn = if_else(perturb_sign=='pos',-asyn,asyn))
# specific model: main effect of perturb_sign or any of its interactions
# (asymmetry = difference between signs)
# interaction between perturb_sign, perturb_type and context (perturb_sign has a
# differential effect depending on the type of perturbation AND the context, i.e. pure
# context makes SCs more asymmetrical but PSs less asymmetrical)
model_asym_3int <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_sign
+ perturb_type:perturb_sign
+ context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_3int <- Anova(model_asym_3int, type="III")
print(anova_table_asym_3int)
# alternative model: all first-order interactions
model_asym_alt <- lmer(asyn ~ context + perturb_type + perturb_sign
# + context:perturb_type
+ context:perturb_sign
+ perturb_type:perturb_sign
# + context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_alt <- Anova(model_asym_alt, type="III")
print(anova_table_asym_alt)
# model comparison
anova(model_asym_alt, model_asym_3int, test=TRUE)
data3_red_inv_df <- data3_red_df %>%
# switch sign of negative perturbations
mutate(asyn = if_else(perturb_sign=='pos',-asyn,asyn))
# specific model: main effect of perturb_sign or any of its interactions
# (asymmetry = difference between signs)
# interaction between perturb_sign, perturb_type and context (perturb_sign has a
# differential effect depending on the type of perturbation AND the context, i.e. pure
# context makes SCs more asymmetrical but PSs less asymmetrical)
model_asym_3int <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_sign
+ perturb_type:perturb_sign
+ context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_3int <- Anova(model_asym_3int, type="III")
print(anova_table_asym_3int)
# alternative model: same as above but no second-order interaction
model_asym_alt <- lmer(asyn ~ context + perturb_type + perturb_sign
# + context:perturb_type
+ context:perturb_sign
+ perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_alt <- Anova(model_asym_alt, type="III")
print(anova_table_asym_alt)
# model comparison
anova(model_asym_alt, model_asym_3int, test=TRUE)
data3_red_inv_df <- data3_red_df %>%
# switch sign of negative perturbations
mutate(asyn = if_else(perturb_sign=='pos',-asyn,asyn))
# specific model: main effect of perturb_sign or any of its interactions
# (asymmetry = difference between signs)
# interaction between perturb_sign, perturb_type and context (perturb_sign has a
# differential effect depending on the type of perturbation AND the context, i.e. pure
# context makes SCs more asymmetrical but PSs less asymmetrical)
model_asym_3int <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_sign
+ perturb_type:perturb_sign
+ context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_3int <- Anova(model_asym_3int, type="III")
print(anova_table_asym_3int)
# alternative model: same as above but no second-order interaction
model_asym_alt <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_type
+ context:perturb_sign
+ perturb_type:perturb_sign
# + context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_alt <- Anova(model_asym_alt, type="III")
print(anova_table_asym_alt)
# model comparison
anova(model_asym_alt, model_asym_3int, test=TRUE)
data3_red_inv_df <- data3_red_df %>%
# switch sign of negative perturbations
mutate(asyn = if_else(perturb_sign=='pos',-asyn,asyn))
# specific model: main effect of perturb_sign or any of its interactions
# (asymmetry = difference between signs)
# interaction between perturb_sign, perturb_type and context (perturb_sign has a
# differential effect depending on the type of perturbation AND the context, i.e. pure
# context makes SCs more asymmetrical but PSs less asymmetrical)
model_asym_3int <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_sign
+ perturb_type:perturb_sign
+ context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_3int <- Anova(model_asym_3int, type="III")
print(anova_table_asym_3int)
# alternative model: same as above but no second-order interaction
model_asym_alt <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_type
+ context:perturb_sign
+ perturb_type:perturb_sign
+ context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_alt <- Anova(model_asym_alt, type="III")
print(anova_table_asym_alt)
# model comparison
anova(model_asym_alt, model_asym_3int, test=TRUE)
data3_red_inv_df <- data3_red_df %>%
# switch sign of negative perturbations
mutate(asyn = if_else(perturb_sign=='pos',-asyn,asyn))
# specific model: main effect of perturb_sign or any of its interactions
# (asymmetry = difference between signs)
# interaction between perturb_sign, perturb_type and context (perturb_sign has a
# differential effect depending on the type of perturbation AND the context, i.e. pure
# context makes SCs more asymmetrical but PSs less asymmetrical)
model_asym_3int <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_sign
+ perturb_type:perturb_sign
+ context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_3int <- Anova(model_asym_3int, type="III")
print(anova_table_asym_3int)
# alternative model: same as above but no second-order interaction
model_asym_alt <- lmer(asyn ~ context + perturb_type + perturb_sign
+ context:perturb_type
+ context:perturb_sign
+ perturb_type:perturb_sign
# + context:perturb_type:perturb_sign
+ (1|subject),
data = data3_red_inv_df,
REML = TRUE) # unbiased estimation of fixed effects
# (not appropriate for model comparison)
anova_table_asym_alt <- Anova(model_asym_alt, type="III")
print(anova_table_asym_alt)
# model comparison
anova(model_asym_alt, model_asym_3int, test=TRUE)
